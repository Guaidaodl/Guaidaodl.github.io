<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Guaidaodl 的博客</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 01 Mar 2020 16:12:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android 开心明星脸 -- Redux(1) - 传递 ViewModel</title>
      <link>http://yoursite.com/2020/02/27/redux-1/</link>
      <guid>http://yoursite.com/2020/02/27/redux-1/</guid>
      <pubDate>Thu, 27 Feb 2020 10:21:58 GMT</pubDate>
      <description>
      
        
        
          &lt;a href=&quot;/2020/02/23/redux-0/&quot; title=&quot;上一篇文章&quot;&gt;上一篇文章&lt;/a&gt;中我列出了关于 MVVM 实践中的问题. 其中第 4 个问题是

&lt;blockquote&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;那嵌套很深的组件如何获取 ViewMode
        
      
      </description>
      
      <content:encoded><![CDATA[<a href="/2020/02/23/redux-0/" title="上一篇文章">上一篇文章</a>中我列出了关于 MVVM 实践中的问题. 其中第 4 个问题是<blockquote><ol start="4"><li>那嵌套很深的组件如何获取 ViewModel?</li></ol></blockquote><p>为什么跳过了第二个和第三个问题呢? 难道有什么深意? 不, 只是因为我看的书先讨论到了这个问题</p><p>其实说到这个问题, 作为一个资深的面向 Github 编程的 Java 程序员, 我脑海中的复现的第一个词是依赖注入.DI 确实是最容易想到, 也可能是最方便的做法. 不过我们还是先看看 Redux 的方案, 然后再回头看看 DI 的方案.</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="单例-全局变量"><a href="#单例-全局变量" class="headerlink" title="单例, 全局变量"></a>单例, 全局变量</h2><p>这个其实最容易想到. 既然整个应用都只有一个 Store, 那我直接把这个 Store 做成单例. 那每一个组件 需要的时候就可以直接拿到了. 上一篇的 <a href="https://github.com/Guaidaodl/Android-Redux/tree/master/Andux-Base" target="_blank" rel="noopener">demo</a> 就把 Store 保存在一个全局变量中.</p><p>这样做在一个小 demo 中当然没有问题, 但是在大项目中明显是行不通的, 组件与 Store 强耦合, 无法复用.</p><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>前面说到 Redux 的核心概念和代码都比较简单, 如果想要比较好的工作需要需要一些其他库的辅助. react-redux 就是其中一个, 该库主要是解决 react 组件如何和 redux 绑定问题. 下面我们来分析这个库的实现思路.</p><h3 id="容器组件和展示组件"><a href="#容器组件和展示组件" class="headerlink" title="容器组件和展示组件"></a>容器组件和展示组件</h3><p>从上一篇的例子可以看出, 一个组件要工作主要有两个职责:</p><ol><li>与 Store 交互. 从 Store 中读取自己需要的信息(props), 在合适的时机派发 action 等.</li><li>根据读取的信息来渲染界面.</li></ol><p>其实可以把两个功能分开到不同的组件. 然后通过组合的方式来实现功能. 通常把负责与 Store 交互的组件叫做容器组件(Container Component), 负责渲染的组件成为展示组件(Presentational Component). 也叫聪明组件(Smart Component) 和傻瓜组件(Dumb Component). 如果了解 Flutter, 这两种组件可以映射到StatefulWidge 和 StatelessWidget.</p><p>通过把一个简单的组件划分成两层以后, 实际负责渲染的组件跟 Store 解耦. 更容易拿来复用. </p><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>React 有一个叫 context 特性, 只要一棵组件树的根节点提供了 Context, 那其他的子节点就可以访问到这个 Context.react-redux 这个库利用了这个特性, 将组件树的根节点换成了一个定义好的 Provider, 这个 Provider的功能就是提供一个含有 store 的 Context.</p><p>经过上面的两个操作. 像上一个 demo 那种简单的组件结构变化如下.</p><p><img src="/images/Redux-1-1.png" alt="图片"></p><p>可以看到变得复杂了一点, 不过最底下的两个 Counter 可以<strong>复用</strong>了.</p><h1 id="模仿"><a href="#模仿" class="headerlink" title="模仿"></a>模仿</h1><p>这个模仿起来还挺麻烦的. 主要两个原因, 一是 react 和 Android 传统 UI 在设计上有巨大的区别.而是因为 Java 不能动态创建类型, 而 react-redux 库中用到了这项技术.</p><ul><li><p>设计上的区别React 中有一个非常核心的概念是 VDOM(Virtual DOM), VDOM 的创建和修改的代价比较小, 所以 react框架可以在每次 State 更新的时候重新创建一个 VDOM 树, VDOM 的层次增加也不容易引起性能问题. 但是在 Android 之中, 并没有与 VDOM 近似的概念(排除 Flutter 与不成熟的 Jetpack Compose),每次都重建整个 View Tree 的话代价巨大, 增加层次也有很大的性能问题. 因此在上一篇的 demo 中, 当 Store 通知 State 变化时并没有重新一个新的 View Tree, 而是更新现有的 View.</p><p>因为同样的原因, 也不能直接像 react-redux 这样通过增加 Provider 和 Container 来解决问题.其实 Provider 和 Container 的指责都和 Android 传统的 View 不一样, 我猜可能因为 react 有 Flutter 的万物皆 Widget 类似的原则, 所以才使用了现在的方法.</p></li><li><p>动态创建类型在 react-redux 库中 Container Component 的代码比较模式化, 所以该库提供了一个 connect 方法来动态创建 Container, 函数的定义如下: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps?, mapDispatchToProps?, mergeProps?, options?</span>)</span></span><br></pre></td></tr></table></figure><p>其返回值也是一个函数, 再调用这函数, 并传入一个需要包装的 Presentational Component 就可以动态产生一个 Containter Component. 用法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(Counter)</span><br></pre></td></tr></table></figure><p>这种操作在静态类型的语言中实在是太难..别说是 Java, 我估计 Dart 都做不到.</p></li></ul><p>所以这次的模仿只能透过现象看本质. 看能不能模仿一下设计思路了.</p><h2 id="Provider-1"><a href="#Provider-1" class="headerlink" title="Provider"></a>Provider</h2><p>前面提到 Provider 其实就是利用 context 这个特性. 正好 Android 当中的所有 View 也都有 context 这个属性, 通常就是对应的 Activity, 所以这里我们只需要让 Activity 实现一个接口, 让 Container<br>Component 对应的东西可以取得 Store 就好. </p><p>实现很简单, 首先定义一个接口.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StoreProvider</span>&lt;<span class="type">StoreType: Store</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> store: Store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让 MainActivity 实现这个接口.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), StoreProvider&lt;CounterStore&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getStore</span><span class="params">()</span></span> = store</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在 View 需要 store 的时候就可以通过 context 来获得</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> context = getContext()</span><br><span class="line"><span class="keyword">if</span> (context <span class="keyword">is</span> StoreProvider&lt;CounterStore&gt;) &#123;</span><br><span class="line">    <span class="keyword">val</span> store = context.store</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是呢, 前面又说到 Containter Component 如果用 View 来模仿的话, 性能会有问题. PresentationalComponent 又不会有读取 store 的操作, 这个方案的价值很低.</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/27/redux-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android 开心明星脸 -- Redux(0) - 初体验</title>
      <link>http://yoursite.com/2020/02/23/redux-0/</link>
      <guid>http://yoursite.com/2020/02/23/redux-0/</guid>
      <pubDate>Sun, 23 Feb 2020 15:47:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;开心明星脸&quot;&gt;&lt;a href=&quot;#开心明星脸&quot; class=&quot;headerlink&quot; title=&quot;开心明星脸&quot;&gt;&lt;/a&gt;开心明星脸&lt;/h1&gt;&lt;p&gt;首先解释一下这个系列的名称的来源, 开心明星脸是很久以前在东南电视台播放的一个综艺
节目. 主要内容就是请找一些长得
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="开心明星脸"><a href="#开心明星脸" class="headerlink" title="开心明星脸"></a>开心明星脸</h1><p>首先解释一下这个系列的名称的来源, 开心明星脸是很久以前在东南电视台播放的一个综艺节目. 主要内容就是请找一些长得跟明星很想的普通人, 比如低配刘德华, 走调张学友之类.</p><h1 id="为什么会有这个系列"><a href="#为什么会有这个系列" class="headerlink" title="为什么会有这个系列"></a>为什么会有这个系列</h1><p>最近正在尝试使用 MVVM 的架构, 遇到很多实践上的问题, 想从业内的一些经验中学习. Android 这边MVVM 起步比较晚, 可参考的不是很多. 于是想从在 MVVM 上迭代了很久的前端框架上学习一下经验. 然后在 Android 上简单的模仿.</p><p>暂定的目标是 React+Redux 和 Angular.js</p><h1 id="实践上遇到的问题"><a href="#实践上遇到的问题" class="headerlink" title="实践上遇到的问题."></a>实践上遇到的问题.</h1><p>我觉得 MVVM 的核心关键在于如何管理状态(ViewModel), 下面是一些我想知道答案的问题:</p><ol><li>一个复杂的页面应该有一个 ViewModel 统一管理, 还是有多个 ViewModel?</li><li>如果有多个 ViewModel, 那多个 ViewModel 之前如何同步数据?</li><li>单一的 ViewModel 如何处理复杂度增加问题?</li><li>那嵌套很深的组件如何获取 ViewModel?</li><li>异步任务如何和 ViewModel 协调?</li><li>弹个 Toast 显示失败信息这个一次性任务如何通过 ViewModel 实现?</li></ol><p>下面就正式开始, 因为相比 Angular.js, Redux 要简单得多, 所以先从 Redux 开始.</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>关于 redux 的信息主要参考了 <a href="https://book.douban.com/subject/27033213/" target="_blank" rel="noopener">深入浅出 React 和 Redux</a> 这本书. 因为本人 JS 水平低下, 主要的知识都来自此书. 在每一篇的学习部分只会罗列一些 Redux 核心概念与涉及思路, 具体的如何使用的内容和相关代码建议各位参考此书或者网络上的其他资料.</p><p>如果完全对 Redux 没有了解的话可能会觉得这部分的内容有一定的断裂感, 不好理解.</p><h2 id="Redux-的基本原则"><a href="#Redux-的基本原则" class="headerlink" title="Redux 的基本原则"></a>Redux 的基本原则</h2><p>Redux 是 React 上一个比较流行的状态管理库. 从 Dan Abramov 改进 Flux 而来. 有三大原则:</p><ul><li>唯一数据源(Single Source Of Truth)</li><li>保持状态只读(State is read-only)</li><li>数据改变只能通过纯函数来完成(Changes are mde with pure functions)</li></ul><p>三个原则中的第一条正好解决了我的第一个疑问. Redux 是从 Flux 发展改进而来. Flux 采用了多个 Store 的方案, 但是多个 Store 之前的依赖关系十分难以管理, 所以 Redux 采用了单一 Store 的方案.</p><h2 id="Redux-的核心概念"><a href="#Redux-的核心概念" class="headerlink" title="Redux 的核心概念"></a>Redux 的核心概念</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>状态, 应该是一个只读不可变的对象.</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>操作.</p><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>存储状态(State)的对象. 对外主要有以下几个功能:</p><ol><li>获取当前的 state.</li><li>订阅状态变化.</li><li>分发(dispatch) Action.</li></ol><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Redux 的核心概念. 也是 Redux 中名字的来源. Store 只负责分发 action, 真正处理 action 的就是 Reducer. Reducer 其实就是一个函数. 接受 state 和 action 两个参数, 并返回一个新的 State. Redux 框架强调了 reducer 最好是<strong>纯函数</strong>.</p><h1 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h1><p>其实 redux 的核心概念比较简单. 所以模仿起来也比较简单.</p><h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><h3 id="State-1"><a href="#State-1" class="headerlink" title="State"></a>State</h3><p>State 一个普通不可变的 Java 对象, 因为要经常会有利用旧 State, 小改一个属性来创建一个新的 state这种操作, JS 里可以用 <a href="https://www.techiediaries.com/react-spread-operator-props-setstate/" target="_blank" rel="noopener">spread operator</a> 在 Java 里可能有点麻烦, 但是如果使用 Kotlin, 则 data class 完美匹配这个需求.</p><h3 id="Action-1"><a href="#Action-1" class="headerlink" title="Action"></a>Action</h3><p>这个没有什么好说的. 就是一个普通对象. 考虑到所有的 action 类型应该是已知的, 可以使用 kotlin 的sealed class.</p><h3 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h3><p>可以对 LiveData 进行一些简单的扩展来实现.</p><h3 id="Reducer-1"><a href="#Reducer-1" class="headerlink" title="Reducer"></a>Reducer</h3><p>一个单方法接口就可以.</p><p>总体来说是比较轻量级的, Redux 的源码其实也不是很多. 只是提出核心的概念, 如果想要真正用起来还需要很多辅助的库. </p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>因为要实现的功能比较少, 其实就只有 Store 是需要定义接口与创建方法. 利用 LiveData 可以比较简单的实现. 核心代码如下, 完整代码在<a href="https://github.com/Guaidaodl/Android-Redux/blob/master/Andux-Base/app/src/main/java/me/guaidaodl/andux/core/Store.kt" target="_blank" rel="noopener">这里</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟 Lifecycle 绑定的 Store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Store</span>&lt;<span class="type">State, Action</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> state: State</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(action: <span class="type">Action</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 照抄 LiveData 里的 observer 相关的接口.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">observe</span><span class="params">(owner: <span class="type">LifecycleOwner</span>, observer: <span class="type">Observer</span>&lt;<span class="type">in</span> <span class="type">State</span>&gt;)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">observeForever</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">in</span> <span class="type">State</span>&gt;)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeObserver</span><span class="params">(observer: <span class="type">Observer</span>&lt;<span class="type">in</span> <span class="type">State</span>&gt;)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeObservers</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建利用 ViewModel 和 LiveData 来实现 Store</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;State, Action&gt;</span> <span class="title">createStore</span><span class="params">(initState: <span class="type">State</span>, reducer: (<span class="type">State</span>, <span class="type">Action</span>) -&gt; <span class="type">State</span>)</span></span>: Store&lt;State, Action&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">object</span>: Store&lt;State, Action&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> liveState = MutableLiveData(initState)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">val</span> state: State <span class="keyword">get</span>() = liveState.value!!</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(action: <span class="type">Action</span>)</span></span> &#123;</span><br><span class="line">            liveState.value = reducer(state, action)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现 createStore 函数的时候考虑过是否直接把 Store 写一个 ViewModel 的子类, 二者功能十分类似.但是考虑到 Redux 强调单一数据源, 一个 store 的生命周期可能横跨多个页面. 最后还是放弃了这个想法.</p><p>另外看了一些 Android 官方关于 ViewModel 和 LiveData 的文章, 感觉思路跟 Flux 差不多.</p><h2 id="简单-Demo"><a href="#简单-Demo" class="headerlink" title="简单 Demo"></a>简单 Demo</h2><p>这里用刚才写的组件写了一个简单的 <a href="https://github.com/Guaidaodl/Android-Redux/tree/master/Andux-Base" target="_blank" rel="noopener">demo</a>. 因为主要关注点在状态管理上, 数据和 UI 绑定的代码没有用任何框架, 长得比较丑, 不用在意.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redux 的概念很简单也很容易实现. 不过现在的内容只解决了是单一数据源还是多个数据源的问题.后续的问题的答案还有待继续探究.</p><p>其实这里的单数据源在我理解里并不是一个应用只有一个 Store 的意思, 而是在同一业务的业务周期内单一.不过这样又会涉及到很多问题, 比如一个页面多个 Tab, 每一个 Tab 都是单独的业务怎么处理等. 还是需要继续研究在业务逻辑复杂的情况下如何使用 Redux.</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/23/redux-0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 SDKMAN 管理开发环境.</title>
      <link>http://yoursite.com/2019/12/23/sdkman/</link>
      <guid>http://yoursite.com/2019/12/23/sdkman/</guid>
      <pubDate>Mon, 23 Dec 2019 05:59:58 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;最近需要在 Mac 上同时使用两个不同的开发环境. 配置起来还比较麻烦. 使用 SDKMAN 则可以比较方便的管理.&lt;/p&gt;
&lt;ul&gt;
&lt;l
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近需要在 Mac 上同时使用两个不同的开发环境. 配置起来还比较麻烦. 使用 SDKMAN 则可以比较方便的管理.</p><ul><li>官网: <a href="https://sdkman.io/" target="_blank" rel="noopener">https://sdkman.io/</a></li></ul><h1 id="安装-SDKMAN"><a href="#安装-SDKMAN" class="headerlink" title="安装 SDKMAN"></a>安装 SDKMAN</h1><p>安装只需要运行一下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s "https://get.sdkman.io" | bash</span><br></pre></td></tr></table></figure><h1 id="搜索和安装-JDK"><a href="#搜索和安装-JDK" class="headerlink" title="搜索和安装 JDK"></a>搜索和安装 JDK</h1><p>跟常见的包管理工具类似, 使用 SDKMAN 安装只需要使用 install 命令, 运行下面的命令就可以安装最新版本的 jdk.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install java</span><br></pre></td></tr></table></figure><p>需要搜索的时则可以使用 list 命令. 比如列出可用的 java 版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk list java</span><br></pre></td></tr></table></figure><p>结果如下:<img src="/images/sdk_list_java.png" alt=""></p><p>安装指定的版本则需要在工具名后面添加 Identifier. 比如安装 jdk 8 需要用一下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install java 8.0.232.j9-adpt</span><br></pre></td></tr></table></figure><h1 id="切换-jdk-的版本"><a href="#切换-jdk-的版本" class="headerlink" title="切换 jdk 的版本"></a>切换 jdk 的版本</h1><p>安装完之后可以利用 use 命令切换不同的版本, 比如切换到 jdk8:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk use java 8.0.232.j9-adpt</span><br></pre></td></tr></table></figure><p>也可以使用 default 命令将 jdk8 设为默认的版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk default java 8.0.232.j9-adpt</span><br></pre></td></tr></table></figure><p>使用 current 命令则可以查看当前版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk current java</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/12/23/sdkman/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Emacs 的 Mode Line 上添加 Git Branch 的名字.</title>
      <link>http://yoursite.com/2019/05/27/add-git-branch-in-emacs-model-line/</link>
      <guid>http://yoursite.com/2019/05/27/add-git-branch-in-emacs-model-line/</guid>
      <pubDate>Mon, 27 May 2019 12:33:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;打算对自己的 Emacs 进行简单的定制, 就从比较简单的地方开始. 其实最正确地做法是用 doom-line.
这篇博客以一个初学者(懂一点基础的 elisp, 但是没有专门学过)的角度写一下自己的研究过程.&lt;/p&gt;
&lt;p&gt;第一步就是先分解一下这个需求, 将其拆分几个小问
        
      
      </description>
      
      <content:encoded><![CDATA[<p>打算对自己的 Emacs 进行简单的定制, 就从比较简单的地方开始. 其实最正确地做法是用 doom-line.这篇博客以一个初学者(懂一点基础的 elisp, 但是没有专门学过)的角度写一下自己的研究过程.</p><p>第一步就是先分解一下这个需求, 将其拆分几个小问题:</p><ol><li>如何在 Emacs 里获取当前的分支名?</li><li>如何定制 Mode Line 里的信息.</li><li>将分支名加入 mode line 中.</li></ol><h1 id="从-Emacs-里获取当前的-Branch-信息"><a href="#从-Emacs-里获取当前的-Branch-信息" class="headerlink" title="从 Emacs 里获取当前的 Branch 信息."></a>从 Emacs 里获取当前的 Branch 信息.</h1><p>获取当前 git 的分支信息可以利用命令 <code>git rev-parse --abbrev-ref HEAD</code> 获取当前分支的名称. 所以这个问题其实可以转化成如何使用 elisp 运行 shell 命令并获取结果. 通过简单地 Google, 可以发现elisp 提供了 <code>shell-command</code> 和 <code>shell-command-to-string</code> 两个函数来执行外部的 shell 命令.</p><p>所以可以通过以下的代码来获取当前的 branch 信息. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(shell-command-to-string &quot;git rev-parse --abbrev-ref HEAD&quot;)</span><br></pre></td></tr></table></figure><h1 id="如何定制-mode-line-里的信息"><a href="#如何定制-mode-line-里的信息" class="headerlink" title="如何定制 mode line 里的信息."></a>如何定制 mode line 里的信息.</h1><p>阅读关于官方两篇关于 mode line 的文档: <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Mode-Line.html" target="_blank" rel="noopener">The Mode Line</a>和 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Format.html#Mode-Line-Format" target="_blank" rel="noopener">Mode Line Format</a> 并参考了一些其他的文档后, 可以比较全面地了解关于 mode line.</p><p>通过第二篇文档, 可以得知 mode line 的显示在大部分时候由 <code>mode-line-format</code> 决定. 可以通过改变<code>mode-line-format</code> 的值来改变 mode line 的显示内容. </p><p><code>mode-line-format</code> 是一个比较复杂的结构, 可以认为是多种类型组成的列表. 主要的类型有:</p><ol><li>string 单纯的显示.</li><li>特别的格式化字符串, 已 % 开头, 比如 %b 代表当前的 buffer 名. 可以参考 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/_0025_002dConstructs.html#g_t_0025_002dConstructs" target="_blank" rel="noopener">%s-Contructs</a></li><li>(:eval form) 执行 form 并把执行结果当做 string 显示.</li></ol><p>明显 3 就是我们需要的. 比如一个简单的只显示 buffer name 和 git 分支名的 mode line 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(setq mode-line-format</span><br><span class="line">(list</span><br><span class="line">&quot;%b&quot;</span><br><span class="line">&quot; &quot;</span><br><span class="line">&#39;(:eval (shell-command-to-string &quot;git rev-parse --abbrev-ref HEAD&quot;))))</span><br></pre></td></tr></table></figure><p>上面只是一个简单的定制, 离可用状态还很远. 后续还可以慢慢优化.</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Mode-Line.html" target="_blank" rel="noopener">The Mode Line</a></li><li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Mode-Line-Format.html#Mode-Line-Format" target="_blank" rel="noopener">Mode Line Format</a></li><li><a href="http://emacs-fu.blogspot.com/2011/08/customizing-mode-line.html" target="_blank" rel="noopener">Customzing mode line</a></li></ol>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/05/27/add-git-branch-in-emacs-model-line/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的 Mac 工具箱</title>
      <link>http://yoursite.com/2018/09/13/software-mac/</link>
      <guid>http://yoursite.com/2018/09/13/software-mac/</guid>
      <pubDate>Thu, 13 Sep 2018 14:48:53 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;作为一个工具控, 一直坚持调教自己的电脑. Mac 有很多不错的工具, 以下是我认为 Mac 装机必备的软件.&lt;/p&gt;
&lt;h1 id=&quot;日常使用&quot;&gt;&lt;a href=&quot;#日常使用&quot; class=&quot;headerlink&quot; title=&quot;日常使用&quot;&gt;&lt;/a&gt;日常使用&lt;/h1&gt;&lt;h
        
      
      </description>
      
      <content:encoded><![CDATA[<p>作为一个工具控, 一直坚持调教自己的电脑. Mac 有很多不错的工具, 以下是我认为 Mac 装机必备的软件.</p><h1 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h1><h2 id="Alfred-Spotlight"><a href="#Alfred-Spotlight" class="headerlink" title="Alfred Spotlight"></a>Alfred <del>Spotlight</del></h2><p>使用过一段时间的 Spotlight 之后还是觉得 Alfred 更顺手, 免费版已经够用.</p><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>浏览器的王者, 无敌的扩展与插件.</p><h2 id="坚果云"><a href="#坚果云" class="headerlink" title="坚果云"></a>坚果云</h2><p>其实云服务很多, 但是国外的 Dropbox, One Driver, Google Drivere 等速度实在是太糟糕,国内的大部分云盘的定位不是同步盘而是存储盘. 再加上十分欣赏坚果云的理念, 所以选择了付费版.空间和流量用来存私人文件的已经十分足够了. 速度也不错, 还提供了历史版本的功能. </p><ul><li><a href="https://www.jianguoyun.com/" target="_blank" rel="noopener">官网</a></li></ul><h2 id="LastPass"><a href="#LastPass" class="headerlink" title="LastPass"></a>LastPass</h2><p>密码管理软件. 网上不停地有各种网站被拖库导致密码泄露的消息. 为了安全, 在不同的软件上使用不同的密码十分必要.但是要记住不同的密码还挺困难的, 所以需要一个密码管理器.</p><p>LastPass 还有生成密码和记录简单笔记的功能, 十分实用, 价格也比 1Password 要便宜一点.</p><ul><li><a href="https://www.lastpass.com" target="_blank" rel="noopener">官网</a></li></ul><h2 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h2><p>剪贴板管理工具, 可以记录文字和图片的复制记录. 功能比较简单, 但是是我见过颜值最高的同类软件.</p><ul><li><a href="https://itunes.apple.com/cn/app/paste-2/id967805235?l=en&mt=12" target="_blank" rel="noopener">Paste - App Store</a></li></ul><h2 id="Snipaste"><a href="#Snipaste" class="headerlink" title="Snipaste"></a>Snipaste</h2><p>截图 + 贴图, 超良心的独立软件. 各种功能可以玩出花来.</p><ul><li><a href="https://zh.snipaste.com/" target="_blank" rel="noopener">官网</a></li></ul><h2 id="Calibre"><a href="#Calibre" class="headerlink" title="Calibre"></a>Calibre</h2><p>书籍类的 iTunes. 管理自己下载的电子书, 还带格式转换功能. 配合坚果云来使用, 可以在不同的设备之间同步书籍.</p><ul><li><a href="https://calibre-ebook.com/" target="_blank" rel="noopener">官网</a></li></ul><h2 id="Office-365"><a href="#Office-365" class="headerlink" title="Office 365"></a>Office 365</h2><p>三件套虽然用得不多, 但是确实是必不可少的软件. 唯一的遗憾就是送的 1TB 的 OneDriver 套餐因为网络问题不太好用.</p><h2 id="XMind-Zen"><a href="#XMind-Zen" class="headerlink" title="XMind Zen"></a>XMind Zen</h2><p>感觉应该是 XMind 抄袭 MindNode 之作, 但是是跨平台的. 免费版已经够用, 配合坚果云可以实现多平台同步.</p><h2 id="Onenote-EverNote"><a href="#Onenote-EverNote" class="headerlink" title="Onenote EverNote"></a>Onenote <del>EverNote</del></h2><p>主要用来收集一些网上的文章和记一些速记. 配合 Chrome 的剪切插件特别方便. 相比 EverNote, 感觉 OneNote 更灵活一点.</p><h2 id="HyperSwitch-Bartender-Divvy"><a href="#HyperSwitch-Bartender-Divvy" class="headerlink" title="HyperSwitch, Bartender, Divvy"></a>HyperSwitch, Bartender, Divvy</h2><p>放在一起是因为我觉得这个应该是一个系统的基础功能, 而 Mac 却没有.</p><p>Mac 在很多方面做得不错, 但是在两个方面做得完全不如 Windows. 一个是文件管理, Finder 比 Windows上的 Explorer 差了不少, 更不用说 Windows 还有 TotalCommander 这种神器.</p><p>另一个是窗口管理, Mac 调整窗口大小十分困难, 没有 Windows 上贴边直接占一个位置的功能. 有了 Divvy就可以方便地调整大小了. 建议在 AppStore 上直接购买.</p><ul><li><a href="https://itunes.apple.com/cn/app/divvy-window-manager/id413857545?l=en&mt=12" target="_blank" rel="noopener">Divvy - App Store</a></li></ul><h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><h2 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h2><p>上网必备. 平常生活没有 Google 还可以, 写程序没有 Google 真的是很太难了. 面向 Github 编程和面向StackOverflow 编程都是依赖与 Google 的.</p><h2 id="NeoVim-Emacs"><a href="#NeoVim-Emacs" class="headerlink" title="NeoVim, Emacs"></a>NeoVim, Emacs</h2><p>VSC 虽好, 但是无法再命令行中使用, NeoVim 是一个良好的补充. 现在的慢慢开始往 Eamcs + Evil 的转移,不过在超大文件上 Emacs 的性能和 Vim 差很多, 这时候还是需要使用 Vim</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>命令行增强, 一个好用的命令行是开发必备. zsh 要比 bash 强大得多, 再加上有 oh-my-zsh 这种开箱即用的配置. 真是爽.</p><h3 id="zsh-的一些常用插件"><a href="#zsh-的一些常用插件" class="headerlink" title="zsh 的一些常用插件:"></a>zsh 的一些常用插件:</h3><ul><li>主题: powerlevel 9k</li><li>自动补全: zsh-autosuggestion</li></ul><h3 id="其他命令行工具"><a href="#其他命令行工具" class="headerlink" title="其他命令行工具"></a>其他命令行工具</h3><ul><li>fzf 交互性命令行.</li><li>z.lua 快速跳转.</li><li>ripgrep 用来替代 grep.</li></ul><h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><p>开发 Android 必备.</p><h2 id="IntelliJ-Idea"><a href="#IntelliJ-Idea" class="headerlink" title="IntelliJ Idea"></a>IntelliJ Idea</h2><p>纯 Java 开发必备. 可惜毕业后就不能使用教育版的激活码.</p><h2 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h2><p>开发 iOS 必备, 实在是不好用. 还好自己只是偶尔写点玩具来玩.</p><h2 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h2><p>文档查找器. 作者每年是一个新版本然后重新收费, 犹记得某一年作者在年度总结里写自己玩了半年的炉石,然后年底随便写写就出新版本了. 不过因为实在是太好用了, 每年依旧乖乖交费.</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/09/13/software-mac/#disqus_thread</comments>
    </item>
    
    <item>
      <title>First Blood</title>
      <link>http://yoursite.com/2018/09/10/First-Blood/</link>
      <guid>http://yoursite.com/2018/09/10/First-Blood/</guid>
      <pubDate>Mon, 10 Sep 2018 13:41:50 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;我的第一篇博客.&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>我的第一篇博客.</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/09/10/First-Blood/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
